import argparse
import logging
import json
import re
import unittest

import apache_beam as beam
from apache_beam.testing import test_pipeline
from apache_beam.testing.util import assert_that
from apache_beam.testing.util import equal_to


class TestJsonParsing(unittest.TestCase):
    def test_json_good_parsing(self):
        # Test if a good formed JSON is parsed
        # Json payload is good and match BQ Table Schema
        json_ok = [b'{"meetingid":"aaa-bbb-ccc", "transcription":"hi",'\
            b'"timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}']

        # Expected Dictionary        
        expected_json_ok = {"meetingid":"aaa-bbb-ccc", "transcription":"hi",
            "timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}

        with test_pipeline.TestPipeline() as p:
            input = p | beam.Create(json_ok)
            output = (input | beam.ParDo(ParseJson())
                                .with_outputs('json_decode_error', 
                                        main='cleared_json'))

            json_cleared = output.cleared_json
            assert_that(json_cleared, equal_to([expected_json_ok]))

    def test_json_bad_parsing(self):
        # Test if a bad formed JSON is parsed
        # Bad Json payload
        json_bad = [b'{meetingid":"aaa-bbb-ccc", "transcription":"oi",'\
            b'"timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}']
        
        expected_json_bad = {'meetingid': 'aaa-bbb-ccc', 
                            'payload': 'b\'{meetingid":"aaa-bbb-ccc", "transcription":"oi",'\
                                '"timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}\'', 
                            'error': 'JSONDecodeError: Expecting property name '\
                                'enclosed in double quotes: line 1 column 2 (char 1)'}

        with test_pipeline.TestPipeline() as p:
            input = p | beam.Create(json_bad)
            output = (input | beam.ParDo(ParseJson())
                                .with_outputs('json_decode_error', 
                                    main='cleared_json'))

            json_error = output.json_decode_error
            assert_that(json_error, equal_to([expected_json_bad]))


class ParseJson(beam.DoFn):
    def process(self, element):
        try:
            element = json.loads(element)
        except ValueError as e:
            meeting = re.search('[a-z]+-[a-z]+-[a-z]+', str(element))
            if meeting:
                meeting = meeting.group()
            else:
                meeting = ''
            error_message = {'meetingid':meeting, 
                            'payload':str(element), 
                            'error': type(e).__name__ + ': ' + str(e)}
            yield beam.pvalue.TaggedOutput('json_decode_error', error_message)
        else:
            yield element


class TestWriteJsonParsedBigquery(unittest.TestCase):
    def test_write_good_json(self):
        json_ok = [{"meetingid":"aaa-bbb-ccc", "transcription":"hi",
            "timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}]

        output_bigquery = 'cool-ml-demos:salesassist.history'

        with test_pipeline.TestPipeline() as p:
            insert_errors = (
                p   
                | beam.Create(json_ok)
                | beam.io.WriteToBigQuery(
                    output_bigquery,
                    schema=TablesProperties.table_schema,
                    insert_retry_strategy='RETRY_ON_TRANSIENT_ERROR',
                    validate=False,
                    create_disposition=beam.io.BigQueryDisposition.CREATE_NEVER,
                    write_disposition=beam.io.BigQueryDisposition.WRITE_APPEND))

            assert_that(insert_errors['FailedRows'], equal_to([]))

    def test_write_bad_json_info(self):
        # Write error message generated by bad json
        info_json_bad = [{'meetingid': 'aaa-bbb-ccc', 
            'payload': 'b\'{meetingid":"aaa-bbb-ccc", "transcription":"oi",'\
            '"timestamp_transcription":"2020-08-24 12:44:31.744957 UTC"}\'',
            'error': 'JSONDecodeError: Expecting property name '\
            'enclosed in double quotes: line 1 column 2 (char 1)'}]

        output_bigquery = 'cool-ml-demos:salesassist.history_error'
        
        with test_pipeline.TestPipeline() as p:
            insert_errors = (
                p
                | beam.Create(info_json_bad)
                | beam.io.WriteToBigQuery(
                    output_bigquery,
                    schema=TablesProperties.error_schema,
                    insert_retry_strategy='RETRY_ON_TRANSIENT_ERROR',
                    validate=False,
                    create_disposition=beam.io.BigQueryDisposition.CREATE_NEVER,
                    write_disposition=beam.io.BigQueryDisposition.WRITE_APPEND))

            assert_that(insert_errors['FailedRows'], equal_to([]))

    def test_fail_write_bad_json(self):
        # Try to write a json with missing field in schema
        json_ok_insert_bad = [{"meetingid":"aaa-bbb-ccc", "transcription":"oi"}]
        expected_output = ('cool-ml-demos:salesassist.history', {'meetingid': 'aaa-bbb-ccc', 'transcription': 'oi'})

        output_bigquery = 'cool-ml-demos:salesassist.history'

        with test_pipeline.TestPipeline() as p:
            insert_errors = (
                p   
                | beam.Create(json_ok_insert_bad)
                | beam.io.WriteToBigQuery(
                    output_bigquery,
                    schema=TablesProperties.table_schema,
                    insert_retry_strategy='RETRY_ON_TRANSIENT_ERROR',
                    validate=False,
                    create_disposition=beam.io.BigQueryDisposition.CREATE_NEVER,
                    write_disposition=beam.io.BigQueryDisposition.WRITE_APPEND))

            assert_that(insert_errors['FailedRows'], equal_to([expected_output]))

    def test_wrap_insertion_error(self):
        insertion_error = [('cool-ml-demos:salesassist.history', 
                            {'meetingid': 'aaa-bbb-ccc', 
                            'transcription': 'oi'})]

        expected_error_message = {'meetingid':'aaa-bbb-ccc', 
                                    'payload':str(('cool-ml-demos:salesassist.history', 
                                        {'meetingid': 'aaa-bbb-ccc', 
                                        'transcription': 'oi'})), 
                                    'error':'bigquery_insertion_error'}

        with test_pipeline.TestPipeline() as p:
            output = (
                p 
                | beam.Create(insertion_error)
                | beam.ParDo(WrapInsertionError()))

            assert_that(output, equal_to([expected_error_message]))

    def test_write_wrapped_error(self):
        insertion_error = [('cool-ml-demos:salesassist.history', 
                    {'meetingid': 'aaa-bbb-ccc', 
                    'transcription': 'oi'})]

        output_bigquery = 'cool-ml-demos:salesassist.history_error'

        with test_pipeline.TestPipeline() as p:
            insert_error = (
                p 
                | beam.Create(insertion_error)
                | beam.ParDo(WrapInsertionError())
                | beam.io.WriteToBigQuery(
                    output_bigquery,
                    schema=TablesProperties.error_schema,
                    insert_retry_strategy='RETRY_ON_TRANSIENT_ERROR',
                    validate=False,
                    create_disposition=beam.io.BigQueryDisposition.CREATE_NEVER,
                    write_disposition=beam.io.BigQueryDisposition.WRITE_APPEND))

            assert_that(insert_error['FailedRows'], equal_to([]))


class PrintPayload(beam.DoFn):
    def process(self, element):
        # meeting = re.search('[a-z]+-[a-z]+-[a-z]+', str(element[1]))
        print(str(element[1]))
        yield element


class WrapInsertionError(beam.DoFn):
    def process(self, element):
        meeting = re.search('[a-z]+-[a-z]+-[a-z]+', str(element[1]))
        if meeting:
            meeting = meeting.group()
        else:
            meeting = ''
        error_message = {'meetingid':meeting, 'payload':str(element), 'error':'bigquery_insertion_error'}
        yield error_message


class TablesProperties:
    table_schema = {
        'fields': [{
            'name': 'meetingid', 'type': 'STRING', 'mode': 'REQUIRED'
        }, {
            'name': 'timestamp_transcription', 'type': 'TIMESTAMP', 'mode': 'REQUIRED'
        }, {
            'name': 'transcription', 'type': 'STRING', 'mode': 'REQUIRED'
        }]
    }

    error_schema = {
        'fields': [{
            'name': 'meetingid', 'type': 'STRING', 'mode': 'NULLABLE'
        }, {
            'name': 'payload', 'type': 'STRING', 'mode': 'NULLABLE'
        }, {
            'name': 'error', 'type': 'STRING', 'mode': 'NULLABLE'
        }]
    }


if __name__ == '__main__':
    unittest.main()
